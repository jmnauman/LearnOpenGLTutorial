Add, sub, mult, div vectors componentwise.
Scalar mult - just multiply each component by the scalar.
Dot product A.B = A0 * B0 + A1 * B1 + A2 * B2... = mag(A)*mag(B)*cos(theta), theta is angle between the vectors. dot prod zero when vectors are perpendicular, 1 when parallel
mag(A) = sqrt(A0^2 + B0^2 +...)
Normalized vector has length of 1. norm(A) = A/mag(A)
Cross prod: AxB = (a1*b2 - a2*b1, a2*b0 - a0 * b2, a0*b1 - a1*b0) (notice how it uses the components of the row you aren't in).

Add, sub matrices componentwise, must have same dimensions.
Scalar mult multiplies each element
 A*B != B*A
To do by hand, multiply each row of A by each col of B as if they're dot products (multiply each component and sum them together). The row/col defines the resulting number in that row/col of the output.
Number of cols on left must match number of rows on right.
If dim(A) = (n,m) and dim(B) = (q, v), dim(A*B) = (n, v)

1 2 x 5 6 = 1*5+2*7 1*6+2*8 = 19, 22
3 4   7 8   3*5+4*7 3*6+4*8   43, 50

Matrix-vector multiplication looks exactly them same, vec is matrix with 1 col. Num cols in matrix must match num rows in vector.

Identity:

1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1

scale 1 by a number for a uniform scaling matrix. Nonuniform scaling is

sx 0 0 0
0 sy 0 0
0 0 sz 0
0 0 0 1

translation:

1  0  0  tx
0  1  0  ty
0  0  1  tz
0  0  0  1

w (4th coord) is a homogenous coordinate. To get 3D vector from homogenous, divide x,y,z by w. w is uaully 1.0. This lets us define the translation matrix above. If w is zero, vector must be a direction
because it can't be translated.

When rotating vectors, there's an angle and a rotation axis. 
Rotation around x, then y, then z introduces gimbal lock. Instead better to rotate once around an arbitrary axis (unit vector) instead of combining individual rotation matrices. 
General rotation matrix is below, but just look it up if you need it.
⎡⎣⎢⎢⎢⎢cosθ+Rx2(1−cosθ)RyRx(1−cosθ)+RzsinθRzRx(1−cosθ)−Rysinθ0RxRy(1−cosθ)−Rzsinθcosθ+Ry2(1−cosθ)RzRy(1−cosθ)+Rxsinθ0RxRz(1−cosθ)+RysinθRyRz(1−cosθ)−Rxsinθcosθ+Rz2(1−cosθ)00001⎤⎦⎥⎥⎥⎥

The above doesn't solve gimbal lock, just makes it harder. Have to represent rotations with quaternions to avoid that. Quaternions aren't explained here.

Can combine individual matrices to get a transform that applies certain effects. Ex if you wanted to scale (S), then translate (T)
w = T*S*v
where T*S is the combined transform. Note that the order of each matrix's effects reads from right to left. Multiplication is not commutative
we usually scale, then rotate, then translate